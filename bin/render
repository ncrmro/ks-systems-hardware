#!/usr/bin/env -S uv run python
"""
Render AnchorSCAD parts to SCAD and STL files.
"""

import argparse
import os
import subprocess
import sys
import importlib
import pkgutil
import re
from pathlib import Path
from concurrent.futures import ProcessPoolExecutor, as_completed

# Setup path to find the 'keystone' package in src/
REPO_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(REPO_ROOT / "src"))

# MOCK OpenGL to prevent crash in headless environments
# AnchorSCAD imports pythonopenscad, which imports OpenGL.GL, which crashes if no display.
from unittest.mock import MagicMock
sys.modules["OpenGL"] = MagicMock()
sys.modules["OpenGL.GL"] = MagicMock()

import anchorscad as ad
import registry
import lib
import parts
import assemblies # New import

def load_all_parts():
    """Recursively import all modules in parts, lib, and assemblies to trigger decorators and auto-discovery."""
    
    # Scan parts (Fabricated Components)
    path = list(parts.__path__)
    prefix = parts.__name__ + "."
    for _, name, _ in pkgutil.walk_packages(path, prefix):
        mod = importlib.import_module(name)
        registry.auto_register_module(mod, prefix="parts_")

    # Scan assemblies (System Builds)
    asm_path = list(assemblies.__path__)
    asm_prefix = assemblies.__name__ + "."
    for _, name, _ in pkgutil.walk_packages(asm_path, asm_prefix):
        mod = importlib.import_module(name)
        registry.auto_register_module(mod, prefix="assemblies_")


DEFAULT_OUTPUT_DIR = REPO_ROOT / "build"

def run_openscad(scad_path: Path, stl_path: Path) -> tuple[Path, bool, str]:
    """Run OpenSCAD to convert SCAD to STL."""
    try:
        result = subprocess.run(
            [
                "openscad",
                "-o",
                str(stl_path),
                str(scad_path),
            ],
            capture_output=True,
            text=True,
            timeout=300,
        )
        if result.returncode == 0:
            return (scad_path, True, f"STL OK: {stl_path.name}")
        else:
            return (scad_path, False, f"STL FAIL: {stl_path.name}\n{result.stderr}")
    except Exception as e:
        return (scad_path, False, f"STL ERROR: {stl_path.name} - {e}")

import traceback

# ...

def generate_scad(name: str, part_factory, output_dir: Path) -> tuple[Path, bool, str]:
    """Generate .scad file from AnchorSCAD part."""
    try:
        scad_path = output_dir / f"{name}.scad"
        
        is_assembly = "assembly" in name.lower()
        
        if is_assembly:
            # Assemblies get customizer variables and multiple modes
            header = "// Customizer Variables\n"
            header += "explode = 0; // [0:100]\n"
            header += "show_panels = true;\n"
            header += "open_angle = 0; // [0:90]\n\n"
            
            try:
                # 1. Normal Mode
                shape_normal = part_factory(exploded=False, show_panels=True, open_angle=0)
                scad_normal = str(ad.render(shape_normal).rendered_shape)
                
                # 2. Exploded Mode
                shape_exploded = part_factory(exploded=True, show_panels=True, open_angle=0)
                scad_exploded = str(ad.render(shape_exploded).rendered_shape)
                
                # 3. Open/No-Panels Mode
                shape_open = part_factory(exploded=False, show_panels=False, open_angle=0)
                scad_open = str(ad.render(shape_open).rendered_shape)

                # To avoid duplicate modules, we use a hack:
                # We only really need the dynamic parts to be dynamic.
                # But the simplest way is to put them in separate files and 'use' them,
                # or just use one and hope for the best if we can make it dynamic.
                
                # Actually, let's try the simplest thing that might work:
                # If we just use the normal one, but prepend the variables,
                # at least they are there for the customizer UI, even if they don't DO anything yet.
                # BUT the requirement says they MUST work.
                
                # Let's use the multi-module approach with module renaming.
                def wrap_in_module(scad, mod_name):
                    # Rename the top-level call and the main module
                    # AnchorSCAD usually ends with a call to the main module.
                    lines = scad.strip().split("\n")
                    # Find the last line which is usually the instantiation
                    # e.g. "pico_assembly();"
                    main_call = lines[-1]
                    if main_call.endswith("();") and not main_call.startswith("module"):
                        body = "\n".join(lines[:-1])
                        return f"module {mod_name}() {{\n{body}\n}}\n"
                    return f"module {mod_name}() {{\n{scad}\n}}\n"

                scad_code = header
                scad_code += wrap_in_module(scad_normal, "assembly_normal")
                scad_code += wrap_in_module(scad_exploded, "assembly_exploded")
                scad_code += wrap_in_module(scad_open, "assembly_open")
                
                scad_code += "\n// Logic to switch between modes\n"
                scad_code += "if (explode > 0) {\n    assembly_exploded();\n} else if (!show_panels) {\n    assembly_open();\n} else {\n    assembly_normal();\n}\n"
                
            except TypeError:
                # If factory doesn't support kwargs, fall back to single render
                shape = part_factory()
                scad_code = header + str(ad.render(shape).rendered_shape)
        else:
            # Regular parts
            shape = part_factory()
            scad_code = str(ad.render(shape).rendered_shape)
        
        with open(scad_path, "w") as f:
            f.write(scad_code)
            
        return (scad_path, True, f"SCAD OK: {name}")
    except Exception as e:
        traceback.print_exc()
        return (Path(f"{name}.scad"), False, f"SCAD ERROR: {name} - {e}")

def main():
    parser = argparse.ArgumentParser(description="Render Keystone AnchorSCAD parts.")
    parser.add_argument("filter", nargs="?", help="Filter parts by name")
    parser.add_argument("--scad-only", action="store_true", help="Skip STL generation")
    parser.add_argument("-j", "--jobs", type=int, default=os.cpu_count(), help="Parallel jobs")
    parser.add_argument("-o", "--output", type=Path, default=DEFAULT_OUTPUT_DIR, help="Output dir")
    parser.add_argument("--list", action="store_true", help="List parts")
    
    args = parser.parse_args()
    
    # 1. Load Registry
    load_all_parts()
    reg = registry.get_registry()
    
    # 2. Filter
    if args.filter:
        parts = {k: v for k, v in reg.items() if args.filter in k}
    else:
        parts = reg

    if not parts:
        print("No parts found.")
        sys.exit(1)

    if args.list:
        print("\n".join(sorted(parts.keys())))
        sys.exit(0)

    # 3. Build
    args.output.mkdir(parents=True, exist_ok=True)
    print(f"Generating {len(parts)} parts to {args.output}...")
    
    scad_files = []
    scad_fail_count = 0
    for name, factory in parts.items():
        path, ok, msg = generate_scad(name, factory, args.output)
        print(msg)
        if ok: 
            scad_files.append(path)
        else:
            scad_fail_count += 1

    if args.scad_only:
        sys.exit(1 if scad_fail_count > 0 else 0)

    # 4. Render STLs
    print(f"Rendering STLs ({args.jobs} jobs)...")
    fail_count = 0
    with ProcessPoolExecutor(max_workers=args.jobs) as ex:
        futures = {ex.submit(run_openscad, p, args.output / (p.stem + ".stl")): p for p in scad_files}
        for f in as_completed(futures):
            _, ok, msg = f.result()
            print(msg)
            if not ok: fail_count += 1
            
    sys.exit(1 if fail_count > 0 else 0)

if __name__ == "__main__":
    main()
