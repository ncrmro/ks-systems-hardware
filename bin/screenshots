#!/usr/bin/env python3
"""
Screenshot utility for Keystone Hardware OpenSCAD models.
Generates PNG screenshots of all assemblies and components.

Zero dependencies - uses only Python standard library.
"""

import hashlib
import json
import os
import subprocess
import sys
from pathlib import Path

# Project paths
SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent
OUTPUT_DIR = PROJECT_ROOT / "screenshots"


def load_env():
    """Load environment variables from .env file if it exists."""
    env_file = PROJECT_ROOT / ".env"
    if env_file.exists():
        with open(env_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, value = line.split("=", 1)
                    os.environ.setdefault(key.strip(), value.strip())


load_env()

# R2 configuration
R2_BUCKET = os.environ.get("R2_BUCKET_NAME", "ks-systems")
R2_ENDPOINT = os.environ.get("R2_ENDPOINT", "")
R2_ACCESS_KEY_ID = os.environ.get("R2_ACCESS_KEY_ID", "")
R2_SECRET_ACCESS_KEY = os.environ.get("R2_SECRET_ACCESS_KEY", "")

# Screenshot settings
WIDTH = 1920
HEIGHT = 1080
COLORSCHEME = "Tomorrow Night"

# Camera settings (translate_x,translate_y,translate_z,rot_x,rot_y,rot_z,distance)
CAMERA_ISOMETRIC = "0,0,0,55,0,25,900"

# Files to screenshot
ASSEMBLIES = [
    "assemblies/minimal.scad",
    "assemblies/pico.scad",
    "assemblies/gpu.scad",
    "assemblies/gpu_aio.scad",
    "assemblies/nas_2disk.scad",
    "assemblies/nas_many.scad",
]

COMPONENTS = [
    # Motherboard assemblies
    "modules/components/motherboard/motherboard.scad",
    "modules/components/motherboard/motherboard_with_ram.scad",
    "modules/components/motherboard/motherboard_full_minitx.scad",
    "modules/components/motherboard/motherboard_full_pico.scad",
    # CPU coolers
    "modules/components/cpu_cooler.scad",
    "modules/components/cpu_cooler_nh_l9.scad",
    # Power
    "modules/components/power/psu_flex_atx.scad",
    "modules/components/power/psu_sfx.scad",
    "modules/components/power/psu_pico.scad",
    "modules/components/power/power_inlet_c14.scad",
    "modules/components/power/barrel_jack_5_5x2_5.scad",
    # Storage
    "modules/components/storage/hdd_3_5.scad",
    "modules/components/storage/ssd_2_5.scad",
    # Cooling
    "modules/components/cooling/fan_120.scad",
    "modules/components/cooling/fan_120mm_15mm.scad",
    "modules/components/cooling/aio_radiator_240.scad",
    "modules/components/cooling/aio_pump.scad",
    # Other components
    "modules/components/gpu.scad",
    "modules/components/pcie_riser.scad",
    "modules/components/ram.scad",
]


def check_docker_available() -> bool:
    """Check if Docker is available."""
    try:
        result = subprocess.run(["docker", "--version"], capture_output=True, text=True)
        return result.returncode == 0
    except FileNotFoundError:
        return False


def screenshot_file_docker(scad_file: Path, output_path: Path, defines: dict = None, extra_args: list = None) -> bool:
    """Take a screenshot using Docker with OpenSCAD container (fallback method)."""
    if not scad_file.exists():
        print(f"  Warning: {scad_file} not found, skipping")
        return False

    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Get relative paths from project root for mounting
    scad_rel = scad_file.relative_to(PROJECT_ROOT) if scad_file.is_relative_to(PROJECT_ROOT) else scad_file
    output_rel = output_path.relative_to(PROJECT_ROOT) if output_path.is_relative_to(PROJECT_ROOT) else output_path

    # Build OpenSCAD command
    openscad_cmd = [
        "openscad",
        f"--imgsize={WIDTH},{HEIGHT}",
        f"--camera={CAMERA_ISOMETRIC}",
        f"--colorscheme={COLORSCHEME}",
    ]

    if defines:
        for key, value in defines.items():
            openscad_cmd.extend(["-D", f"{key}={value}"])

    if extra_args:
        openscad_cmd.extend(extra_args)

    openscad_cmd.extend(["-o", f"/openscad/{output_rel}", f"/openscad/{scad_rel}"])

    # Build Docker command
    docker_cmd = [
        "docker", "run",
        "--rm",
        "--init",
        "-v", f"{PROJECT_ROOT}:/openscad",
        "-u", f"{os.getuid()}:{os.getgid()}",
        "openscad/openscad:latest",
        "xvfb-run", "-a"
    ] + openscad_cmd

    try:
        result = subprocess.run(docker_cmd, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"    -> {output_path.relative_to(PROJECT_ROOT)} (via Docker)")
            return True
        else:
            print(f"    Error (Docker): {result.stderr}")
            return False
    except Exception as e:
        print(f"    Error running Docker: {e}")
        return False


def screenshot_file(scad_file: Path, output_path: Path, defines: dict = None, extra_args: list = None, use_docker: bool = False) -> bool:
    """Take a screenshot of a single OpenSCAD file.
    
    Args:
        scad_file: Path to the SCAD file to render
        output_path: Path where the PNG should be saved
        defines: Dictionary of OpenSCAD defines (-D parameters)
        extra_args: Additional command-line arguments
        use_docker: Force using Docker (useful for headless environments)
    
    Returns:
        True if successful, False otherwise
    """
    if not scad_file.exists():
        print(f"  Warning: {scad_file} not found, skipping")
        return False

    output_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"  Rendering: {scad_file.relative_to(PROJECT_ROOT) if scad_file.is_relative_to(PROJECT_ROOT) else scad_file.name}")

    # Try Docker first if explicitly requested or if native OpenSCAD fails
    if use_docker:
        if check_docker_available():
            return screenshot_file_docker(scad_file, output_path, defines, extra_args)
        else:
            print("    Warning: Docker not available, falling back to native OpenSCAD")

    # Try native OpenSCAD
    env = os.environ.copy()
    env["QT_QPA_PLATFORM"] = "offscreen"

    cmd = [
        "openscad",
        f"--imgsize={WIDTH},{HEIGHT}",
        f"--camera={CAMERA_ISOMETRIC}",
        f"--colorscheme={COLORSCHEME}",
    ]

    if defines:
        for key, value in defines.items():
            cmd.append("-D")
            cmd.append(f"{key}={value}")

    if extra_args:
        cmd.extend(extra_args)

    cmd.extend(["-o", str(output_path), str(scad_file)])

    try:
        result = subprocess.run(cmd, env=env, capture_output=True, text=True, timeout=60)
        if result.returncode == 0:
            print(f"    -> {output_path.relative_to(PROJECT_ROOT)}")
            return True
        else:
            # Check if error is related to display/GL context
            stderr_lower = result.stderr.lower()
            if any(keyword in stderr_lower for keyword in ["egl", "display", "gl context", "offscreenview"]):
                print("    Native OpenSCAD failed (display/GL issue), trying Docker fallback...")
                if check_docker_available():
                    return screenshot_file_docker(scad_file, output_path, defines, extra_args)
                else:
                    print(f"    Error: {result.stderr}")
                    return False
            else:
                print(f"    Error: {result.stderr}")
                return False
    except FileNotFoundError:
        # OpenSCAD not found, try Docker as fallback
        print("    OpenSCAD not found locally, trying Docker fallback...")
        if check_docker_available():
            return screenshot_file_docker(scad_file, output_path, defines, extra_args)
        else:
            print("  Error: Neither OpenSCAD nor Docker is available.")
            return False
    except subprocess.TimeoutExpired:
        print("    Timeout: Rendering took too long, trying Docker fallback...")
        if check_docker_available():
            return screenshot_file_docker(scad_file, output_path, defines, extra_args)
        else:
            print("    Error: Rendering timed out and Docker not available")
            return False


def screenshot_assemblies(use_docker: bool = False) -> int:
    """Screenshot all assembly files (normal, exploded, and open views)."""
    print("\n=== Assemblies ===\n")

    count = 0
    for rel_path in ASSEMBLIES:
        scad_file = PROJECT_ROOT / rel_path
        name = scad_file.stem

        # Normal view
        output_path = OUTPUT_DIR / f"assembly-{name}.png"
        if screenshot_file(scad_file, output_path, use_docker=use_docker):
            count += 1

        # Exploded view
        output_path_exploded = OUTPUT_DIR / f"assembly-{name}-exploded.png"
        if screenshot_file(scad_file, output_path_exploded, defines={"explode": 30}, use_docker=use_docker):
            count += 1

        # Open view (panels hidden, bottom panel still visible)
        output_path_open = OUTPUT_DIR / f"assembly-{name}-open.png"
        if screenshot_file(scad_file, output_path_open, defines={"show_panels": "false"}, use_docker=use_docker):
            count += 1

    return count


def screenshot_components(use_docker: bool = False) -> int:
    """Screenshot all component files."""
    print("\n=== Components ===\n")

    count = 0
    for rel_path in COMPONENTS:
        scad_file = PROJECT_ROOT / rel_path
        name = scad_file.stem
        output_path = OUTPUT_DIR / f"component-{name}.png"

        if screenshot_file(scad_file, output_path, use_docker=use_docker):
            count += 1

    return count


def get_file_md5(file_path: Path) -> str:
    """Calculate MD5 hash of a file."""
    md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            md5.update(chunk)
    return md5.hexdigest()


def get_r2_etag(key: str, env: dict) -> str | None:
    """Get the ETag (MD5) of an object in R2. Returns None if not found."""
    cmd = [
        "aws", "s3api", "head-object",
        "--bucket", R2_BUCKET,
        "--key", key,
        "--endpoint-url", R2_ENDPOINT,
    ]
    try:
        result = subprocess.run(cmd, env=env, capture_output=True, text=True)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            # ETag is quoted, strip the quotes
            return data.get("ETag", "").strip('"')
    except (json.JSONDecodeError, FileNotFoundError):
        pass
    return None


def upload_to_r2(pattern: str = "assembly-*-exploded.png") -> int:
    """Upload matching screenshots to Cloudflare R2.

    Only uploads files that have changed (based on MD5 hash comparison).

    Requires:
    - AWS CLI installed
    - R2 environment variables set (R2_ENDPOINT, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY)
    """
    print(f"\n=== Uploading to R2 ({R2_BUCKET}) ===\n")

    if not R2_ENDPOINT:
        print("  Error: R2_ENDPOINT environment variable not set")
        return 0

    if not R2_ACCESS_KEY_ID or not R2_SECRET_ACCESS_KEY:
        print("  Error: R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY must be set")
        return 0

    files = list(OUTPUT_DIR.glob(pattern))
    if not files:
        print(f"  No files matching '{pattern}' found")
        return 0

    # Set AWS credentials for the subprocess
    env = os.environ.copy()
    env["AWS_ACCESS_KEY_ID"] = R2_ACCESS_KEY_ID
    env["AWS_SECRET_ACCESS_KEY"] = R2_SECRET_ACCESS_KEY

    uploaded = 0
    skipped = 0
    for file_path in files:
        key = f"openscad-screenshots/{file_path.name}"
        local_md5 = get_file_md5(file_path)
        remote_etag = get_r2_etag(key, env)

        if local_md5 == remote_etag:
            print(f"  Skipping: {file_path.name} (unchanged)")
            skipped += 1
            continue

        print(f"  Uploading: {file_path.name} -> s3://{R2_BUCKET}/{key}")

        cmd = [
            "aws", "s3", "cp",
            str(file_path),
            f"s3://{R2_BUCKET}/{key}",
            "--endpoint-url", R2_ENDPOINT,
        ]

        try:
            result = subprocess.run(cmd, env=env, capture_output=True, text=True)
            if result.returncode == 0:
                print(f"    -> Uploaded")
                uploaded += 1
            else:
                print(f"    Error: {result.stderr}")
        except FileNotFoundError:
            print("  Error: aws CLI not found. Please install AWS CLI.")
            return uploaded

    if skipped > 0:
        print(f"\n  Skipped {skipped} unchanged files")

    return uploaded


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Keystone Hardware Screenshot Generator")
    parser.add_argument("--scan-dir", type=Path, help="Directory to scan for .scad files")
    parser.add_argument("--upload", action="store_true", help="Upload to R2")
    parser.add_argument("--use-docker", action="store_true", help="Use Docker with xvfb-run for rendering (fallback for headless environments)")
    args = parser.parse_args()

    print("Keystone Hardware Screenshot Generator")
    print("=" * 40)
    print(f"Output: {OUTPUT_DIR}")
    print(f"Resolution: {WIDTH}x{HEIGHT}")
    if args.use_docker:
        print("Rendering mode: Docker (xvfb-run)")
    elif check_docker_available():
        print("Rendering mode: Native OpenSCAD (Docker fallback available)")
    else:
        print("Rendering mode: Native OpenSCAD (Docker not available)")

    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    total = 0
    
    if args.scan_dir:
        if not args.scan_dir.exists():
             print(f"Error: {args.scan_dir} does not exist.")
             sys.exit(1)
        
        print(f"\n=== Scanning {args.scan_dir} ===\n")
        for scad_file in args.scan_dir.glob("*.scad"):
            name = scad_file.stem
            output_path = OUTPUT_DIR / f"build-{name}.png"
            # Use autocenter/viewall for scanned files
            if screenshot_file(scad_file, output_path, extra_args=["--autocenter", "--viewall"], use_docker=args.use_docker):
                total += 1
    else:
        # Default behavior: screenshot hardcoded lists
        total += screenshot_assemblies(use_docker=args.use_docker)
        total += screenshot_components(use_docker=args.use_docker)

    print(f"\nDone! Generated {total} screenshots in: {OUTPUT_DIR}")

    # Upload exploded views to R2 if requested or legacy behavior (only if env vars set?)
    # Let's make it explicit via flag OR if previously it was automatic.
    # Previous code: upload_to_r2() was called at end.
    # Let's keep it automatic if env vars are set, but respectful of the flag if we want to force it?
    # Actually, let's just use the flag to ENABLE it, to avoid accidental uploads in CI if env vars happened to be there (unlikely).
    # But to preserve backward compat for whoever runs this locally:
    # If args.upload is True, do it. 
    
    if args.upload:
        uploaded = upload_to_r2("*-exploded.png")
        if uploaded > 0:
            print(f"\nUploaded {uploaded} exploded views to R2")

if __name__ == "__main__":
    main()
